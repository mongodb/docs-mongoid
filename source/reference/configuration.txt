.. _configuration:

*************
Configuration
*************

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Mongoid is customarily configured through a ``mongoid.yml`` file that specifies
options and clients. The simplest configuration is as follows, which configures
Mongoid to talk to a MongoDB server at "localhost:27017" and use the database
named "mongoid".

.. code-block:: yaml

  development:
    clients:
      default:
        database: mongoid
        hosts:
          - localhost:27017

The top level key in the configuration file, ``development`` in the above
example, refers to the environment name which the application is executing in,
i.e. ``development``, ``test`` or ``production``. The third level key,
``default`` in the above example, refers to the Mongo client name.
Most applications will use a single client named ``default``.


Generating Default Configuration
================================

If you are using {+ror+}, you can have Mongoid generate a default
configuration file for you by running the following command:

.. code-block:: bash

  rails g mongoid:config

The configuration file will be placed in ``config/mongoid.yml``. An
initializer will also be created and placed in
``config/initializers/mongoid.rb``. It is recommended that all configuration
be specified in ``config/mongoid.yml``, but if you prefer, the ``mongoid.rb``
initializer may also be used to set configuration options. Note, though, that
settings in ``mongoid.yml`` always take precedence over settings in the
initializer.

If you are not using {+ror+}, you can copy the minimal configuration
given above and save it as ``config/mongoid.yml``.


Loading Mongoid Configuration
=============================

If you are using {+ror+}, Mongoid configuration is automatically loaded
for the current environment as stored in ``Rails.env`` when the application
loads.

You may need to configure the ORM for your application to be Mongoid by
adding the following to ``application.rb``:

.. code-block:: ruby

  config.generators do |g|
    g.orm :mongoid
  end

If you are not using {+ror+}, Mongoid configuration must be loaded
manually. This can be done via the ``Mongoid.load!`` method, which takes
the configuration file path as its argument, as follows:

.. code-block:: ruby

  # Use automatically detected environment name
  Mongoid.load!("path/to/your/mongoid.yml")

  # Specify environment name manually
  Mongoid.load!("path/to/your/mongoid.yml", :production)

When Mongoid is asked to automatically detect the environment name,
it does so by examining the following sources, in order:

- If ``Rails`` top level constant is defined, ``Rails.env``.
- If ``Sinatra`` top level constant is defined, ``Sinatra::Base.environment``.
- The ``RACK_ENV`` environment variable.
- The ``MONGOID_ENV`` environment variable.

It is also possible to configure Mongoid directly in Ruby, without using
a configuration file. This configuration style does not support the concept
of environments - whatever configuration is provided, it is applied to the
current environment - but it does support defining multiple clients.

.. code-block:: ruby

  Mongoid.configure do |config|
    config.clients.default = {
      hosts: ['localhost:27017'],
      database: 'my_db',
    }

    config.log_level = :warn
  end

.. note::

  Mongoid must be configured *before* any component of it is used or referenced.
  Once a component is used or referenced, changing configuration may not apply
  changes to already instantiated components.


.. _configuration-options:

Mongoid Configuration Options
=============================

The following annotated example ``mongoid.yml`` demonstrates how Mongoid
can be configured.

Mongoid delegates to the Ruby driver for client configuration. Please review
`the driver documentation <https://mongodb.com/docs/ruby-driver/current/reference/create-client/>`_
for details on driver options.

.. code-block:: yaml


.. _load-defaults:

Version Based Defaults
======================

Mongoid supports setting the configuration options to the defaults for specific
versions. This is useful for upgrading to a new Mongoid version. When upgrading
your Mongoid version, the following should be set on ``Mongoid::Config``:

.. code:: ruby

  Mongoid.configure do |config|
    config.load_defaults <OLD VERSION>
  end

This way, when upgrading to a new version of Mongoid, your code will run with
the configuration options from the previous version of Mongoid. Then,
one-by-one, you can change the feature flags for the new version, and test that
your code still acts as expected. Once all of the new feature flags have been
accounted for, the call to ``load_defaults`` may be changed to take in the *new*
version, and all of the changed feature flags may be removed.

For example, suppose we're upgrading from 7.5 to 8.0. Between these two versions,
two feature flags were added: ``legacy_attributes`` and ``map_big_decimal_to_decimal128``.
Before upgrading to Mongoid 8, add the following to your ``Mongoid::Config``:

.. code:: ruby

  Mongoid.configure do |config|
    config.load_defaults 7.5
  end

After upgrading to Mongoid 8.0 in your ``Gemfile``, any feature flags will
remain set to their 7.5 default behavior: ``legacy_attributes: true,
map_big_decimal_to_decimal128: false``. You may then flip these feature flags
one-by-one to their 8.0 behavior:

.. code:: ruby

  Mongoid.configure do |config|
    config.load_defaults 7.5
    config.legacy_attributes = false
    # config.map_big_decimal_to_decimal128 = true
  end

We recommend do these one at a time, so in the example above we leave the
second flag commented out. After verifying your code works as expected with the
``legacy_attributes`` flag turned off, the ``map_big_decimal_to_decimal128``
setting can be uncommented. Once that functionality is verified as well, both
of those lines can be removed and the ``load_defaults`` replaced with:

.. code:: ruby

  Mongoid.configure do |config|
    config.load_defaults 8.0
  end


ERb Preprocessing
=================

When loading a configuration file, Mongoid processes it with ERb before
parsing it as YAML. This allows, for example, constructing the contents of
the configuration file at runtime based on environment variables:

.. code-block:: yaml

  development:
    clients:
      default:
        uri: "<%= ENV['MONGODB_URI'] %>"

.. note::

  When outputting values from ERb, ensure the values are valid YAML and
  escape them as needed.

.. note::

  Since ERb rendering is performed prior to YAML parsing, all ERb directives
  in the configuration file are evaluated, including those occurring in YAML
  comments.

Logging
=======

When configuring logging, it is important to keep in mind that Mongoid
provides a model layer on top of the MongoDB Ruby driver, and the driver
dispatches the CRUD operations to the MongoDB deployment. Therefore, some
of the logging output in an application using Mongoid comes from Mongoid
itself, and some comes from the driver.

The Mongo client is a Ruby driver client instance, therefore
the logger of a Mongo client is the Ruby driver logger, not the Mongoid
logger. In other words:

.. code-block:: ruby

  # Ruby driver logger, not Mongoid logger
  Mongoid.client(:default).logger

Depending on whether Mongoid is used in a {+ror+} application, and how
both Mongoid and Ruby driver are configured, they may use the same logger
instance or different instances, potentially with different configurations.

In {+ror+} Application
----------------------------

When used in a {+ror+} application, Mongoid by default inherits
the logger and the log level from Rails, and sets the driver's logger
to the same logger instance:

.. code-block:: ruby

  Rails.logger === Mongoid.logger
  # => true

  Mongoid.logger === Mongo::Logger.logger
  # => true

To change the log level, use `standard Rails configuration
<https://guides.rubyonrails.org/debugging_rails_applications.html#log-levels>`_.
Place the following in one of environment configuration files, such as
``config/environments/production.rb``:

.. code-block:: ruby

  Rails.application.configure do
    config.log_level = :debug
  end

.. note::

  The ``log_level`` Mongoid configuration option is not used when Mongoid operates
  in a Rails application, because Mongoid inherits Rails' log level in this case.

To configure either Mongoid or driver logger differently from the Rails logger,
use an initializer as follows:

.. code-block:: ruby

  Rails.application.configure do
    config.after_initialize do
      # Change Mongoid log destination and/or level
      Mongoid.logger = Logger.new(STDERR).tap do |logger|
        logger.level = Logger::DEBUG
      end

      # Change driver log destination and/or level
      Mongo::Logger.logger = Logger.new(STDERR).tap do |logger|
        logger.level = Logger::DEBUG
      end
    end
  end

.. note::

  There is currently no provision in the Ruby standard library ``Logger``
  to return the log device (i.e. the ``IO`` object) that a logger is using.
  To have, for example, Mongoid and/or the Ruby driver log to the
  standard Rails log file (e.g. ``log/development.log``) but with a
  different level from standard Rails logger (``Rails.logger``), the
  file must be opened separately and the resulting ``IO`` object passed to
  the ``Logger`` constructor.

.. note::

  Since by default Mongoid sets its own logger and the driver's logger to the
  same instance as the Rails logger, modifying any of the instances affects
  all of them. For example the following changes log level for all three
  loggers, unless the application assigned a separate ``Logger`` instance
  to ``Mongo::Logger.logger`` as described above:

  .. code-block:: ruby

    Mongoid::Logger.logger.level = Logger::DEBUG

Standalone
----------

When not loaded in a {+ror+} application, Mongoid respects the
``log_level`` top level configuration option. It can be given in the
configuration file as follows:

.. code-block:: yaml

  development:
    clients:
      default:
        # ...
    options:
      log_level: :debug

... or when configuring Mongoid inline:

.. code-block:: ruby

  Mongoid.configure do |config|
    config.log_level = :debug
  end

The default log destination in Mongoid 7.1 and higher is standard error.
The default log destination in Mongoid 7.0 and lower is standard output.
To change the log destination, create a new logger instance as follows:

.. code-block:: ruby

  Mongoid.logger = Logger.new(STDERR).tap do |logger|
    logger.level = Logger::DEBUG
  end

To change the Ruby driver log level or destination:

.. code-block:: ruby

  Mongo::Logger.logger = Logger.new(STDERR).tap do |logger|
    logger.level = Logger::DEBUG
  end

To set the driver logger to be the same as the Mongoid logger:

.. code-block:: ruby

  Mongo::Logger.logger = Mongoid.logger

.. note::

  Mongoid does not alter the driver's logger when running in
  standalone mode.

.. _time-zones:

Time Zones
==========

Mongoid uses ActiveSupport's time zone functionality, which is far
more robust than Ruby's standard library. Importantly, ActiveSupport
allows configuration of ``Time.zone``, a thread-global variable which
provides context for working with date and time values.

While a thorough treatment of time zones in Ruby is outside the scope
of this tutorial, the easiest and most reliable way of achieving correct
time zone handling is as follows:

1. Set the operating system's time zone to UTC. For example, on Linux:

.. code-block:: bash

  cp /usr/share/zoneinfo/UTC /etc/localtime

2. Set your application default time zone to UTC:

.. code-block:: ruby

  # If using Rails, in application.rb:
  class Application < Rails::Application
    config.time_zone = 'UTC'
  end

  # If not using Rails:
  Time.zone = 'UTC'

3. In each controller and job class, set the appropriate time zone in a
   ``before_filter`` at the earliest possible stage. As an example,
   if each user of your application can set their own time zone,
   you may wish to do:

.. code-block:: ruby

  class ApplicationController < ActionController::Base
    before_filter :fetch_user,
                  :set_time_zone

    def set_time_zone
      Time.zone = @user.time_zone
    end
  end

4. From here, you may work with times naturally in the local time zone.
   For example, in a view:

.. code-block:: ruby

  Turned into a pumpkin after <%= cinderella.updated_at.seconds_after_midnight %> seconds!

5. Use ActiveSupport methods instead of the Ruby standard library.

   - ``Time.zone.now`` or ``Time.current` instead of ``Time.now``
   - ``Date.current`` instead of ``Date.today``

   Critically, note that the latter Ruby standard library methods reference
   your system time zone (e.g. UTC) and not the value of ``Time.zone``.
   As it is very easy to mistake these similarly named methods, we recommend to
   use `Rubocop's Rails/TimeZone cop
   <https://docs.rubocop.org/rubocop-rails/cops_rails.html#railstimezone>`_ in your CI.

Setting time zone on data loaded from MongoDB
---------------------------------------------

MongoDB stores all times in UTC without time zone information.
Mongoid models load and returns time values as instances of
``ActiveSupport::TimeWithZone``. You may set the ``use_utc`` option
to control how Mongoid sets the time zone when loading from the database:

- If false (default), Mongoid will use ``Time.zone`` to set the time
  zone of time values are loaded from database.
- If true, Mongoid will always set the time zone as UTC on loaded
  time values.

``use_utc`` only affects how data is loaded, and does not affect
how data is persisted. For example, if you assign a ``Time`` or
``ActiveSupport::TimeWithZone`` instance to a time field, the time
zone information of the assigned instance always will be used
irrespective of the ``use_utc`` setting. Alternatively, if you
assign a string value to a time field, any time zone information
in the string will be used if present. If the string does not include
time zone information it will be parsed according to ``Time.zone``.
To illustrate:

.. code-block:: ruby

  Time.use_zone("Asia/Kolkata") do

    # String does not include time zone, so "Asia/Kolkata" will be used
    ghandi.born_at = "1869-10-02 7:10 PM"

    # Time zone in string (-0600) will be used
    amelia.born_at = "1897-07-24 11:30 -0600"
  end


Configuring ``SSLContext``
==========================
It may be desirable to further configure TLS options in your application, for
example by enabling or disabling certain ciphers.

This can be done by setting TLS context hooks on the Ruby driver -- TLS context
hooks are user-provided ``Proc``\(s) that will be invoked before any TLS socket
connection in the driver and can be used to modify the underlying
``OpenSSL::SSL::SSLContext`` object used by the socket.

To set TLS context hooks, add ``Proc``\(s) to the ``Mongo.tls_context_hooks``
array. This can be done in an initializer. The example below adds a hook
that only enables the "AES256-SHA" cipher.

.. code-block:: ruby

  Mongo.tls_context_hooks.push(
    Proc.new { |context|
      context.ciphers = ["AES256-SHA"]
    }
  )

  # Only the AES256-SHA cipher will be enabled from this point forward

Every ``Proc`` in ``Mongo.tls_context_hooks`` will be passed an
``OpenSSL::SSL::SSLContext`` object as its sole argument. These procs will
be executed sequentially during socket creation.

.. warning::

  TLS context hooks are global and will affect all ``Mongo::Client`` instances
  in an application.

For more information about TLS context hooks, including best practices for
assigning and removing them, see `the Ruby driver documentation <https://mongodb.com/docs/ruby-driver/current/reference/create-client/#modifying-sslcontext>`_.


Network Compression
===================

Mongoid supports compression of messages to and from MongoDB servers. This functionality is provided by
the Ruby driver, which implements the three algorithms that are supported by MongoDB servers:

- `Snappy <https://google.github.io/snappy/>`_: ``snappy`` compression
  can be used when connecting to MongoDB servers starting with the 3.4 release,
  and requires the `snappy <https://rubygems.org/gems/snappy>`_ library to be
  installed.
- `Zlib <https://zlib.net/>`_: ``zlib`` compression can be used when
  connecting to MongoDB servers starting with the 3.6 release.
- `Zstandard <https://facebook.github.io/zstd/>`_: ``zstd`` compression can be
  used when connecting to MongoDB servers starting with the 4.2 release, and
  requires the `zstd-ruby <https://rubygems.org/gems/zstd-ruby>`_ library to
  be installed.

To use wire protocol compression, configure the Ruby driver options within ``mongoid.yml``:

.. code-block:: yaml

  development:
    # Configure available database clients. (required)
    clients:
      # Define the default client. (required)
      default:
        # ...
        options:
          # These options are Ruby driver options, documented in
          # https://mongodb.com/docs/ruby-driver/current/reference/create-client/
          # ...
          # Compressors to use. (default is to not use compression)
          # Valid values are zstd, zlib or snappy - or any combination of the three
          compressors: ["zstd", "snappy"]

If no compressors are explicitly requested, the driver will not use compression,
even if the required dependencies for one or more compressors are present on the
system.

The driver chooses the first compressor of the ones requested that is also supported
by the server. The ``zstd`` compressor is recommended as it produces the highest
compression at the same CPU consumption compared to the other compressors.

For maximum server compatibility all three compressors can be specified, e.g.
as ``compressors: ["zstd", "snappy", "zlib"]``.


Client-Side Encryption
======================

When loading the configuration file, Mongoid permits the file to contain
``BSON::Binary`` instances which are used for specifying ``keyId`` in
the schema map for `client-side encryption
<https://www.mongodb.com/docs/ruby-driver/current/reference/in-use-encryption/client-side-encryption/>`_,
as the following example shows:

.. code-block:: yaml

  development:
    clients:
      default:
        database: blog_development
        hosts: [localhost:27017]
        options:
          auto_encryption_options:
            key_vault_namespace: 'keyvault.datakeys'
            kms_providers:
              local:
                key: "z7iYiYKLuYymEWtk4kfny1ESBwwFdA58qMqff96A8ghiOcIK75lJGPUIocku8LOFjQuEgeIP4xlln3s7r93FV9J5sAE7zg8U"
            schema_map:
              blog_development.comments:
                properties:
                  message:
                    encrypt:
                      keyId:
                        - !ruby/object:BSON::Binary
                          data: !binary |-
                            R/AgNcxASFiiJWKXqWGo5w==
                          type: :uuid
                      bsonType: "string"
                      algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
                bsonType: "object"


Usage with Forking Servers
==========================

When using Mongoid with a forking web server such as Puma, or any application
that otherwise forks to spawn child processes, special considerations apply.

If possible, we recommend to not perform any MongoDB operations in the parent
process prior to forking, which will avoid any forking-related pitfalls.

A detailed technical explanation of how the Mongo Ruby Driver handles forking
is given in the `driver's "Usage with Forking Servers" documentation
<https://www.mongodb.com/docs/ruby-driver/current/reference/create-client/#usage-with-forking-servers>`.
In a nutshell, to avoid various connection errors such as ``Mongo::Error::SocketError``
and ``Mongo::Error::NoServerAvailable``, you must do the following:

1. Disconnect MongoDB clients in the parent Ruby process immediately *before*
   forking using ``Mongoid.disconnect_clients``. This ensures the parent and child
   process do not accidentally reuse the same sockets and have I/O conflicts.
   Note that ``Mongoid.disconnect_clients`` does not disrupt any in-flight
   MongoDB operations, and will automatically reconnect when you perform new
   operations.
2. Reconnect your MongoDB clients in the child Ruby process immediately *after*
   forking using ``Mongoid.reconnect_clients``. This is required to respawn
   the driver's monitoring threads in the child process.

Most web servers provide hooks that can be used by applications to
perform actions when the worker processes are forked. The following
are configuration examples for several common Ruby web servers.

Puma
----

Use the ``on_worker_boot`` hook to reconnect clients in the workers and
the ``before_fork`` and ``on_refork`` hooks to close clients in the
parent process (`Puma documentation <https://puma.io/puma/#clustered-mode>`_).

.. code-block:: ruby

  # config/puma.rb

  # Runs in the Puma master process before it forks a child worker.
  before_fork do
    Mongoid.disconnect_clients
  end

  # Required when using Puma's fork_worker option. Runs in the
  # child worker 0 process before it forks grandchild workers.
  on_refork do
    Mongoid.disconnect_clients
  end

  # Runs in each Puma child process after it forks from its parent.
  on_worker_boot do
    Mongoid.reconnect_clients
  end

Unicorn
-------

Use the ``after_fork`` hook to reconnect clients in the workers and
the ``before_fork`` hook to close clients in the parent process
(`Unicorn documentation <https://yhbt.net/unicorn/Unicorn/Configurator.html>`_):

.. code-block:: ruby

  # config/unicorn.rb

  before_fork do |_server, _worker|
    Mongoid.disconnect_clients
  end

  after_fork do |_server, _worker|
    Mongoid.reconnect_clients
  end

Passenger
---------

Use the ``starting_worker_process`` hook to reconnect clients in the workers
(`Passenger documentation
<https://www.phusionpassenger.com/library/indepth/ruby/spawn_methods/#unintentional-file-descriptor-sharing>`_).
Passenger does not appear to have a hook that is invoked in the parent process
before the workers are forked.

.. code-block:: ruby

  if defined?(PhusionPassenger)
    PhusionPassenger.on_event(:starting_worker_process) do |forked|
      Mongoid.reconnect_clients if forked
    end
  end


.. _query-cache-middleware:

Query Cache Middleware
======================

Enabling Query Cache for Rack Web Requests
------------------------------------------

The MongoDB Ruby Driver provides a Rack middleware which enables the :ref:`Query Cache
<query-cache>` for the duration of each web request. Below is an example of
how to enable the Query Cache Middleware in a {+ror+} application:

.. code-block:: ruby

  # config/application.rb

  # Add Mongo::QueryCache::Middleware at the bottom of the middleware stack
  # or before other middleware that queries MongoDB.
  config.middleware.use Mongo::QueryCache::Middleware

Please refer to the `Rails on Rack guide
<https://guides.rubyonrails.org/rails_on_rack.html#configuring-middleware-stack>`_
for more information about using Rack middleware in Rails applications.

Enabling Query Cache for ActiveJob
----------------------------------

The MongoDB Ruby Driver also provides Query Cache middleware for ActiveJob.
You may enable it for all jobs in an initializer:

.. code-block:: ruby

  # config/initializers/active_job.rb

  # Enable Mongo driver query cache for ActiveJob
  ActiveSupport.on_load(:active_job) do
    include Mongo::QueryCache::Middleware::ActiveJob
  end

Or for a specific job class:

.. code-block:: ruby

  class MyJob < ActiveJob::Base
    include Mongo::QueryCache::Middleware::ActiveJob
  end


Development Configuration
=========================

Driver's default configuration is suitable for production deployment.
In development, some settings can be adjusted to provide a better developer
experience.

- ``:server_selection_timeout``: set this to a low value (e.g., ``1``)
  if your MongoDB server is running locally and you start it manually. A low
  server selection timeout will cause the driver to fail quickly when there is
  no server running.

Sample recommended development configuration:

.. code-block:: yaml

  development:
    clients:
      default:
        database: mongoid
        hosts:
          - localhost:27017
        options:
          server_selection_timeout: 1
