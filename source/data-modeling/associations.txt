.. _mongoid-associations:

============
Associations
============

.. facet::
   :name: genre
   :values: reference

.. meta::
   :keywords: ruby framework, odm, code example

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

Associations in {+odm+} allow you to create relationships between models. In
this guide, you can learn about the different types of associations that
{+odm+} supports and how to use them in your application.

Referenced Associations
------------------------

Referenced associations allow you to create a relationship between two models
where one model references the other. {+odm+} supports the following referenced
association types:

- ``has_one``
- ``has_many``
- ``belongs_to``
- ``has_and_belongs_to_many``

The following sections describe how to use each of these association types.

Has One
~~~~~~~

You can use the ``has_one`` macro to declare that documents represented by one class also contain a
document represented by a separate child class. The
following example creates a ``Band`` class with a ``has_one`` relationship to a
``Studio`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-one
   :end-before: # end-has-one

When you declare a ``has_one`` association, the child class must also use the
``belongs_to`` association that references the parent class. The following
example shows the ``Studio`` class referenced in the preceding ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-one-child
   :end-before: # end-has-one-child

To learn more about the ``belongs_to`` macro, see the :ref:`Belongs To
<mongoid-belongs-to>` section.

You can use validations to ensure that the child
class is present in your parent class, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-one-validation
   :end-before: # end-has-one-validation
   :emphasize-lines: 6

To learn more about validations in {+odm+}, see the :ref:`Validations
<mongoid-validation>` guide.

Has Many
~~~~~~~~

You can use the ``has_many`` macro to declare that documents represented by a class contain
multiple child documents represented by another class. The following
example creates a ``Band`` class with a ``has_many`` relationship to a
``Members`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many
   :end-before: # end-has-many

When you declare a ``has_many`` association, the child class must also use the
``belongs_to`` association that references the parent class. The following
example shows the ``Member`` class referenced in the preceding ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-child
   :end-before: # end-has-many-child

To learn more about the ``belongs_to`` macro, see the :ref:`Belongs To
<mongoid-belongs-to>` section.

You can use validations to ensure that the child
class is present in your parent class, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-validation
   :end-before: # end-has-many-validation
   :emphasize-lines: 6

To learn more about validations in {+odm+}, see the :ref:`Validations
<mongoid-validation>` guide.

Retrieve Association Information
````````````````````````````````

You can use the ``any?`` method on a ``has_many`` association to determine if the
association contains any documents without retrieving the entire set of
documents from the database.

The following example uses the ``any?`` method to determine if documents in the
``Band`` class contain any ``Members`` documents:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-any
   :end-before: # end-has-many-any

You can also use the ``any?`` method with a filter to find documents that match
a specified criteria, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-any-filter
   :end-before: # end-has-many-any-filter

You can supply a class name to the ``any?`` method to filter the results by the
name of the class. This is useful for polymorphic associations:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-any-class
   :end-before: # end-has-many-any-class

.. note::

   After the data of the associated class is loaded to {+odm+}, subsequent calls
   to the ``any?`` method do not query the database. Instead, {+odm+} uses the
   data that is already loaded in memory.

You can also call the ``exists?`` method to determine if there are any persisted
documents in the association. The ``exists?`` method always queries the
database and checks only for documents that have been saved to the database.
The ``exists?`` method does not allow for filtering and does not accept any
arguments.

The following example uses the ``exists?`` method to determine if there are any persisted
``Members`` documents in the ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-many-exists
   :end-before: # end-has-many-exists

.. _mongoid-belongs-to:

Belongs To
~~~~~~~~~~

Use the ``belongs_to`` macro to declare that a document represented by one class
is a child of a document represented by another
class. By default, the ``_id`` field of the parent class is stored in the child
class. The following example creates a ``Members`` class with a ``belongs_to``
association to a ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-belongs-to
   :end-before: # end-belongs-to

You can allow {+odm+} to persist documents to the database without storing the
``_id`` of the associated parent class by setting the ``optional`` option to
``true``, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-belongs-to-optional
   :end-before: # end-belongs-to-optional

.. tip::

   You can globally change the default behavior of the ``belongs_to``
   association to not require their parent class by setting the
   ``belongs_to_required_by_default`` configuration option to ``false`` in your
   application's configuration settings.

You can specify a ``belongs_to`` association in a child class without specifying a matching
``has_one`` or ``has_many`` association in the parent class. When doing so, you
can't access the fields of the child document from the parent class, but you can
access the parent fields that are stored in the child class, such as the
parent's ``_id`` field. In the following example, the ``Band``
class cannot access the ``Members`` class, but the ``Members`` class can access the
``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-belongs-to-one-way
   :end-before: # end-belongs-to-one-way

For clarity, you can optionally set the ``inverse_of`` option to ``nil`` to
indicate that the parent class does not contain a ``has_one`` or ``has_many``
association to the child class, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-belongs-to-inverse
   :end-before: # end-belongs-to-inverse

Has and Belongs To Many
~~~~~~~~~~~~~~~~~~~~~~~

Use the ``has_and_belongs_to_many`` macro to declare that a class model contains
a many-to-many relationship with another class. In a many-to-many relationship,
each document in one class can be associated with multiple documents in another
class. The following example creates a ``Band`` class with a
``has_and_belongs_to_many`` relationship to a ``Members`` class. A ``Band`` document can
reference multiple ``Members`` documents, and a ``Members`` document can
reference multiple ``Band`` documents.

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-and-belongs-to-many
   :end-before: # end-has-and-belongs-to-many

When you declare a ``has_and_belongs_to_many`` association, both model instances
store a list of the associated document's ``_id`` values. You can set the
``inverse_of`` option to ``nil`` to store the associated document's ``_id`` values in
only one of the model instances. The following example prompts {+odm+} to store
the associated document's ``_id`` values in only the ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-has-and-belongs-to-many-inverse
   :end-before: # end-has-and-belongs-to-many-inverse

.. tip::

   When you update a document that has a ``has_and_belongs_to_many`` association,
   {+odm+} sets the ``updated_at`` field of updated document but does not set the
   ``updated_at`` field of the associated documents.

Query Referenced Associations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use an aggregation pipeline to query for documents across referenced
associations. The aggregation pipeline allows you to create queries across
multiple collections and manipulate data into a specified format. To learn more
about using the aggregation pipeline, see the :ref:`Aggregation
<mongoid-aggregation>` guide.

For simple queries, you can query the association directly. When you directly
query on a collection, you can query only on fields and values that are in the
collection itself. You cannot directly query on collections
associated to the one you are querying.

For example, consider the following ``Band`` and ``Tour`` classes:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-query-models
   :end-before: # end-query-models

The following example queries the ``Tour`` class for documents that have a
``year`` value of ``2000`` or greater and saves the ``band_id`` of those
documents. It then queries the ``Band`` class for documents that have those
``band_id`` values.

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-association-query
   :end-before: # end-association-query

Embedded Associations
---------------------

You can use embedded associations to store different types of documents in the
same collection. {+odm+} supports embedded associations with the following 
macros:

- ``embeds_one``
- ``embeds_many``
- ``embedded_in``
- ``recursively_embeds_one``
- ``recursively_embeds_many``

The following sections describe how to use these association types.

Embeds One
~~~~~~~~~~

To specify that a class model contains an embedded document of a different
class type, use the ``embeds_one`` macro in the parent class and the ``embedded_in``
macro in the embedded class. The following example creates a ``Band`` class with
an embedded ``Label`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-one
   :end-before: # end-embed-one

{+odm+} stores documents embedded with the ``embeds_one`` macro in the
parent document as a field with the same name as the embedded class. The
preceding ``Label`` documents are stored in the ``Band`` document, as shown in
the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-one-stored
   :end-before: # end-embed-one-stored

You can store the embedded document with a different name by using the
``store_as`` option, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-store-as
   :end-before: # end-embed-store-as

Embeds Many
~~~~~~~~~~~

To specify that a class model contains multiple embedded documents of a
different class type, use the ``embeds_many`` macro in the parent class and the
``embedded_in`` macro in the embedded class. The following example creates a
``Band`` class with multiple embedded ``Album`` type documents:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-many
   :end-before: # end-embed-many

{+odm+} stores documents embedded with the ``embeds_many`` macro in the
parent document as an array field with the same name as the embedded class. The
preceding ``Album`` documents are stored in the ``Band`` document, as shown in
the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-many-stored
   :end-before: # end-embed-many-stored

You can store the embedded document with a different name by using the
``store_as`` option, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embed-many-store-as
   :end-before: # end-embed-many-store-as

Recursive Embedding
~~~~~~~~~~~~~~~~~~~

You can embed one or more documents of the same type into a parent
class by using the ``recursively_embeds_one`` and ``recursively_embeds_many``
macros. Both macros provide accessors for the parent and child documents through
a ``parent_*`` method and a ``child_*`` method, where ``*`` represents the name
of the class. The following example creates a ``Band`` class that recursively
embeds multiple other ``Band`` documents to represent multiple band names:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-recursive-embed
   :end-before: # end-recursive-embed

You can access the parent and child documents through the ``parent_band`` and
``child_band`` methods, as shown in the following example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-recursive-embed-access
   :end-before: # end-recursive-embed-access

Query Embedded Associations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can access embedded documents when querying the collection of the parent
class by using dot notation.

The following example uses dot notation to query ``Tour`` type documents that
are embedded in a ``Band`` class. The query returns documents that have a
``tours.year`` value of ``2000`` or greater:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-query
   :end-before: # end-embedded-query

You can use the ``pluck()`` projection method to retrieve embedded documents
without retrieving their associated parent documents, as shown in the following
example:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-query-pluck
   :end-before: # end-embedded-query-pluck

You can use {+odm+} query methods to perform **embedded matching**, which allows
you to query on embedded associations of documents that are already loaded in
the application. {+odm+} implements embedded matching without sending queries to
the server.

The following query operators are supported with embedded matching:

- :manual:`Comparison operators </reference/operator/query-comparison/>`
- :manual:`Logical operators </reference/operator/query-logical/>`
- :manual:`Array query operators </reference/operator/query-array/>`
- :manual:`$exists </reference/operator/query/exists/>`
- :manual:`$mod </reference/operator/query/mod/>`
- :manual:`$type </reference/operator/query/type/>`
- :manual:`$regex </reference/operator/query/regex/>`
- :manual:`Bitwise operators </reference/operator/query-bitwise/>`
- :manual:`$comment </reference/operator/query/comment/>`

The following example queries the embedded ``tours`` field of a loaded ``Band``
document by using the ``$gte`` comparison operator:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-matching
   :end-before: # end-embedded-matching

Embedded matching on loaded documents has the following known limitations:

- Embedded matching is not implemented for the following features:
  
  - :ref:`Text search <mongoid-text-search>`
  - :manual:`Geospatial query operators </reference/operator/query-geospatial/>`
  - Operators that execute JavaScript code, such as :manual:`$where </reference/operator/query/where/>`
  - Operators that are implemented through other server functionality, such as
    :manual:`$expr <https://mongodb.com/docs/manual/reference/operator/query/expr/>`
    and :manual:`$jsonSchema
    <https://mongodb.com/docs/manual/reference/operator/query/jsonSchema/>`

- {+odm+} expands ``Range`` arguments to hashes with ``$gte`` and ``$lte``
  conditions. This can lead to invalid queries in some cases and raises a an
  ``InvalidQuery`` exception.

- With the ``$regex`` operator, you cannot specify a regular expression object
  as a pattern while also providing options to the ``$options`` field. You can
  only provide options if the regular expression pattern is a string.

- MongoDB Server versions 4.0 and earlier do not strictly validate ``$type``
  arguments.

Omit _id Fields
~~~~~~~~~~~~~~~

By default, {+odm+} adds an ``_id`` field to embedded documents. You can omit
this field from embedded documents by explicitly specifying the ``_id`` field in
your model and omitting the default value. The following example instructs {+odm+}
not to add an ``_id`` field to the ``Albums`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-omit-id
   :end-before: # end-embedded-omit-id
   :emphasize-lines: 4

In the preceding ``Albums`` class, the ``_id`` field is not automatically added.
Without a default value, {+odm+} does not store the value in the database
unless you provide one in your model.

Delete Embedded Associations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can delete child documents from ``embeds_many`` associations by using one of
the following methods:

- ``clear()``
- ``delete_all()``
- ``destroy_all()``

The ``clear()`` method uses the :manual:`$unset operator
</reference/operator/update/unset>` operator to remove an entire embedded
association from the parent document. The ``clear()`` method does not run any
``destroy`` callbacks. The following example uses the ``clear()``
method to remove all embedded associations from the ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-clear
   :end-before: # end-embedded-clear

The ``delete_all()`` method uses the :manual:`$pullAll operator
</reference/operator/update/pullAll>` operator to remove documents in an
embedded association. ``delete_all()`` loads the association if it has not
yet been loaded, then only removes the documents that exist in the application.
The ``delete_all()`` method does not run any ``destroy`` callbacks. 
The following example uses the ``delete_all()`` method to remove all embedded
``Album`` documents from the ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-delete-all
   :end-before: # end-embedded-delete-all

The ``destroy_all()`` method also uses the :manual:`$pullAll operator
</reference/operator/update/pullAll>` operator to remove documents in an
embedded association. It also runs any ``destroy`` callbacks that are defined on
the associated documents. The following example uses the ``destroy_all()``
method to remove all embedded ``Album`` documents from the ``Band`` class:

.. literalinclude:: /includes/data-modeling/associations.rb
   :language: ruby
   :start-after: # start-embedded-destroy-all
   :end-before: # end-embedded-destroy-all
